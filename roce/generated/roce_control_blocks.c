/* Automatically generated by p4c-pna-p4tc from roce.p4 on Thu Jun  6 17:42:19 2024
 */
#include "roce_parser.h"
struct p4tc_filter_fields p4tc_filter_fields;

struct internal_metadata {
    __u16 pkt_ether_type;
} __attribute__((aligned(4)));

struct __attribute__((__packed__)) Main_drop_n_table_key {
    u32 keysz;
    u32 maskid;
    u32 field0; /* hdr.ip.dstAddr */
} __attribute__((aligned(8)));
#define MAIN_DROP_N_TABLE_ACT_MAIN_DROP_CONDITIONAL 6
#define MAIN_DROP_N_TABLE_ACT_MAIN_NOP 5
#define MAIN_DROP_N_TABLE_ACT_NOACTION 0
struct __attribute__((__packed__)) Main_drop_n_table_value {
    unsigned int action;
    u32 hit:1,
    is_default_miss_act:1,
    is_default_hit_act:1;
    union {
        struct {
        } _NoAction;
        struct __attribute__((__packed__)) {
            u16 index;
        } Main_drop_conditional;
        struct {
        } Main_nop;
    } u;
};
struct __attribute__((__packed__)) Main_fib_table_key {
    u32 keysz;
    u32 maskid;
    u32 field0; /* hdr.ip.dstAddr */
} __attribute__((aligned(8)));
#define MAIN_FIB_TABLE_ACT_MAIN_SET_NHID 3
#define MAIN_FIB_TABLE_ACT_NOACTION 0
struct __attribute__((__packed__)) Main_fib_table_value {
    unsigned int action;
    u32 hit:1,
    is_default_miss_act:1,
    is_default_hit_act:1;
    union {
        struct {
        } _NoAction;
        struct __attribute__((__packed__)) {
            u32 index;
        } Main_set_nhid;
    } u;
};
struct __attribute__((__packed__)) Main_mark_ecn_table_key {
    u32 keysz;
    u32 maskid;
    u32 field0; /* hdr.ip.dstAddr */
} __attribute__((aligned(8)));
#define MAIN_MARK_ECN_TABLE_ACT_MAIN_SET_ECN 4
#define MAIN_MARK_ECN_TABLE_ACT_MAIN_NOP 5
#define MAIN_MARK_ECN_TABLE_ACT_NOACTION 0
struct __attribute__((__packed__)) Main_mark_ecn_table_value {
    unsigned int action;
    u32 hit:1,
    is_default_miss_act:1,
    is_default_hit_act:1;
    union {
        struct {
        } _NoAction;
        struct __attribute__((__packed__)) {
            u8 codepoint;
        } Main_set_ecn;
        struct {
        } Main_nop;
    } u;
};
struct __attribute__((__packed__)) Main_nh_table_key {
    u32 keysz;
    u32 maskid;
    u32 field0; /* nh_index_0 */
} __attribute__((aligned(8)));
#define MAIN_NH_TABLE_ACT_MAIN_DROP 1
#define MAIN_NH_TABLE_ACT_MAIN_SET_NH 2
#define MAIN_NH_TABLE_ACT_NOACTION 0
struct __attribute__((__packed__)) Main_nh_table_value {
    unsigned int action;
    u32 hit:1,
    is_default_miss_act:1,
    is_default_hit_act:1;
    union {
        struct {
        } _NoAction;
        struct {
        } Main_drop;
        struct __attribute__((__packed__)) {
            u64 dmac;
            u32 port;
        } Main_set_nh;
    } u;
};
struct __attribute__((__packed__)) Main_roce_table_key {
    u32 keysz;
    u32 maskid;
    u8 field0; /* hdr.ib_bth.opcode */
    u32 field1; /* hdr.ib_bth.dest_qp */
    u32 field2; /* hdr.ip.dstAddr */
} __attribute__((aligned(8)));
#define MAX_MAIN_ROCE_TABLE_KEY_MASKS 128
struct Main_roce_table_key_mask {
    __u8 mask[sizeof(struct Main_roce_table_key)];
} __attribute__((aligned(8)));
#define MAIN_ROCE_TABLE_ACT_MAIN_DROP_CONDITIONAL 6
#define MAIN_ROCE_TABLE_ACT_MAIN_NOP 5
#define MAIN_ROCE_TABLE_ACT_NOACTION 0
struct __attribute__((__packed__)) Main_roce_table_value {
    unsigned int action;
    u32 hit:1,
    is_default_miss_act:1,
    is_default_hit_act:1;
    __u32 priority;
    union {
        struct {
        } _NoAction;
        struct __attribute__((__packed__)) {
            u16 index;
        } Main_drop_conditional;
        struct {
        } Main_nop;
    } u;
};

static __always_inline int process(struct __sk_buff *skb, struct headers_t *hdr, struct pna_global_metadata *compiler_meta__)
{
    struct hdr_md *hdrMd;

    unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    u8* hdr_start = pkt;
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    u32 ebpf_one = 1;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;

    struct metadata_t *meta;
    hdrMd = BPF_MAP_LOOKUP_ELEM(hdr_md_cpumap, &ebpf_zero);
    if (!hdrMd)
        return TC_ACT_SHOT;
    unsigned ebpf_packetOffsetInBits = hdrMd->ebpf_packetOffsetInBits;
    hdr_start = pkt + BYTES(ebpf_packetOffsetInBits);
    hdr = &(hdrMd->cpumap_hdr);
    meta = &(hdrMd->cpumap_usermeta);
{
        struct p4tc_ext_bpf_params ext_params = {};
        struct p4tc_ext_bpf_val ext_val = {};
        struct p4tc_ext_bpf_val *ext_val_ptr;
        u8 hit;
        u32 nh_index_0 = 0;
        u32 drop_count_0 = 0;
        {
if (/* hdr->ip.isValid() */
            hdr->ip.ebpf_valid && (hdr->ip.ttl > 1)) {
/* fib_table_0.apply() */
                {
                    /* construct key */
                    struct p4tc_table_entry_act_bpf_params__local params = {
                        .pipeid = p4tc_filter_fields.pipeid,
                        .tblid = 2
                    };
                    struct Main_fib_table_key key;
                    __builtin_memset(&key, 0, sizeof(key));
                    key.keysz = 32;
                    key.field0 = hdr->ip.dstAddr;
                    struct p4tc_table_entry_act_bpf *act_bpf;
                    /* value */
                    struct Main_fib_table_value *value = NULL;
                    /* perform lookup */
                    act_bpf = bpf_p4tc_tbl_read(skb, &params, sizeof(params), &key, sizeof(key));
                    value = (struct Main_fib_table_value *)act_bpf;
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                    } else {
                        hit = value->hit;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case MAIN_FIB_TABLE_ACT_MAIN_SET_NHID: 
                                {
                                    nh_index_0 = value->u.Main_set_nhid.index;
                                }
                                break;
                            case MAIN_FIB_TABLE_ACT_NOACTION: 
                                {
                                }
                                break;
                        }
                    } else {
                    }
                }
;
                /* nh_table_0.apply() */
                {
                    /* construct key */
                    struct p4tc_table_entry_act_bpf_params__local params = {
                        .pipeid = p4tc_filter_fields.pipeid,
                        .tblid = 1
                    };
                    struct Main_nh_table_key key;
                    __builtin_memset(&key, 0, sizeof(key));
                    key.keysz = 32;
                    key.field0 = nh_index_0;
                    struct p4tc_table_entry_act_bpf *act_bpf;
                    /* value */
                    struct Main_nh_table_value *value = NULL;
                    /* perform lookup */
                    act_bpf = bpf_p4tc_tbl_read(skb, &params, sizeof(params), &key, sizeof(key));
                    value = (struct Main_nh_table_value *)act_bpf;
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                    } else {
                        hit = value->hit;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case MAIN_NH_TABLE_ACT_MAIN_DROP: 
                                {
/* drop_packet() */
                                    drop_packet();
                                }
                                break;
                            case MAIN_NH_TABLE_ACT_MAIN_SET_NH: 
                                {
                                    hdr->ethernet.dstAddr = value->u.Main_set_nh.dmac;
                                    /* send_to_port(value->u.Main_set_nh.port) */
                                    compiler_meta__->drop = false;
                                    send_to_port(value->u.Main_set_nh.port);
                                }
                                break;
                            case MAIN_NH_TABLE_ACT_NOACTION: 
                                {
                                }
                                break;
                        }
                    } else {
                    }
                }
;
                /* mark_ecn_table_0.apply() */
                {
                    /* construct key */
                    struct p4tc_table_entry_act_bpf_params__local params = {
                        .pipeid = p4tc_filter_fields.pipeid,
                        .tblid = 3
                    };
                    struct Main_mark_ecn_table_key key;
                    __builtin_memset(&key, 0, sizeof(key));
                    key.keysz = 32;
                    key.field0 = hdr->ip.dstAddr;
                    struct p4tc_table_entry_act_bpf *act_bpf;
                    /* value */
                    struct Main_mark_ecn_table_value *value = NULL;
                    /* perform lookup */
                    act_bpf = bpf_p4tc_tbl_read(skb, &params, sizeof(params), &key, sizeof(key));
                    value = (struct Main_mark_ecn_table_value *)act_bpf;
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                    } else {
                        hit = value->hit;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case MAIN_MARK_ECN_TABLE_ACT_MAIN_SET_ECN: 
                                {
                                    hdr->ip.diffserv = (hdr->ip.diffserv | (u8)value->u.Main_set_ecn.codepoint);
                                }
                                break;
                            case MAIN_MARK_ECN_TABLE_ACT_MAIN_NOP: 
                                {
                                }
                                break;
                            case MAIN_MARK_ECN_TABLE_ACT_NOACTION: 
                                {
                                }
                                break;
                        }
                    } else {
                    }
                }
;
                /* drop_n_table_0.apply() */
                {
                    /* construct key */
                    struct p4tc_table_entry_act_bpf_params__local params = {
                        .pipeid = p4tc_filter_fields.pipeid,
                        .tblid = 4
                    };
                    struct Main_drop_n_table_key key;
                    __builtin_memset(&key, 0, sizeof(key));
                    key.keysz = 32;
                    key.field0 = hdr->ip.dstAddr;
                    struct p4tc_table_entry_act_bpf *act_bpf;
                    /* value */
                    struct Main_drop_n_table_value *value = NULL;
                    /* perform lookup */
                    act_bpf = bpf_p4tc_tbl_read(skb, &params, sizeof(params), &key, sizeof(key));
                    value = (struct Main_drop_n_table_value *)act_bpf;
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                    } else {
                        hit = value->hit;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case MAIN_DROP_N_TABLE_ACT_MAIN_DROP_CONDITIONAL: 
                                {
                                    __builtin_memset(&ext_params, 0, sizeof(struct p4tc_ext_bpf_params));
                                    ext_params.pipe_id = p4tc_filter_fields.pipeid;
                                    ext_params.ext_id = 1;
                                    ext_params.inst_id = 1;
                                    ext_params.index = value->u.Main_drop_conditional.index;

                                    ext_val_ptr = bpf_p4tc_extern_md_read(skb, &ext_params, sizeof(ext_params));
                                    if (!ext_val_ptr) 
                                         return TC_ACT_SHOT;
ext_val = *ext_val_ptr;
                                    __builtin_memcpy(&drop_count_0, ext_val.out_params, sizeof(u32 ));
                                    if (drop_count_0 > 0) {
                                        drop_count_0 = (drop_count_0 + 4294967295);
                                        /* drop_counter_0.write(value->u.Main_drop_conditional.index, drop_count_0) */
                                        __builtin_memset(&ext_params, 0, sizeof(struct p4tc_ext_bpf_params));
                                        ext_params.pipe_id = p4tc_filter_fields.pipeid;
                                        ext_params.ext_id = 1;
                                        ext_params.inst_id = 1;
                                        ext_params.index = value->u.Main_drop_conditional.index;

                                        __builtin_memcpy(ext_val.out_params, &drop_count_0, sizeof(u32 ));
                                        bpf_p4tc_extern_md_write(skb, &ext_params, sizeof(ext_params), &ext_val, sizeof(ext_val));
;
                                        /* drop_packet() */
                                        drop_packet();
                                    }
                                }
                                break;
                            case MAIN_DROP_N_TABLE_ACT_MAIN_NOP: 
                                {
                                }
                                break;
                            case MAIN_DROP_N_TABLE_ACT_NOACTION: 
                                {
                                }
                                break;
                        }
                    } else {
                    }
                }
;
                /* roce_table_0.apply() */
                {
                    /* construct key */
                    struct p4tc_table_entry_act_bpf_params__local params = {
                        .pipeid = p4tc_filter_fields.pipeid,
                        .tblid = 5
                    };
                    struct Main_roce_table_key key;
                    __builtin_memset(&key, 0, sizeof(key));
                    key.keysz = 64;
                    key.field0 = hdr->ib_bth.opcode;
                    key.field1 = hdr->ib_bth.dest_qp;
                    key.field2 = hdr->ip.dstAddr;
                    struct p4tc_table_entry_act_bpf *act_bpf;
                    /* value */
                    struct Main_roce_table_value *value = NULL;
                    /* perform lookup */
                    act_bpf = bpf_p4tc_tbl_read(skb, &params, sizeof(params), &key, sizeof(key));
                    value = (struct Main_roce_table_value *)act_bpf;
                    if (value == NULL) {
                        /* miss; find default action */
                        hit = 0;
                    } else {
                        hit = value->hit;
                    }
                    if (value != NULL) {
                        /* run action */
                        switch (value->action) {
                            case MAIN_ROCE_TABLE_ACT_MAIN_DROP_CONDITIONAL: 
                                {
                                    __builtin_memset(&ext_params, 0, sizeof(struct p4tc_ext_bpf_params));
                                    ext_params.pipe_id = p4tc_filter_fields.pipeid;
                                    ext_params.ext_id = 1;
                                    ext_params.inst_id = 1;
                                    ext_params.index = value->u.Main_drop_conditional.index;

                                    ext_val_ptr = bpf_p4tc_extern_md_read(skb, &ext_params, sizeof(ext_params));
                                    if (!ext_val_ptr) 
                                         return TC_ACT_SHOT;
ext_val = *ext_val_ptr;
                                    __builtin_memcpy(&drop_count_0, ext_val.out_params, sizeof(u32 ));
                                    if (drop_count_0 > 0) {
                                        drop_count_0 = (drop_count_0 + 4294967295);
                                        /* drop_counter_0.write(value->u.Main_drop_conditional.index, drop_count_0) */
                                        __builtin_memset(&ext_params, 0, sizeof(struct p4tc_ext_bpf_params));
                                        ext_params.pipe_id = p4tc_filter_fields.pipeid;
                                        ext_params.ext_id = 1;
                                        ext_params.inst_id = 1;
                                        ext_params.index = value->u.Main_drop_conditional.index;

                                        __builtin_memcpy(ext_val.out_params, &drop_count_0, sizeof(u32 ));
                                        bpf_p4tc_extern_md_write(skb, &ext_params, sizeof(ext_params), &ext_val, sizeof(ext_val));
;
                                        /* drop_packet() */
                                        drop_packet();
                                    }
                                }
                                break;
                            case MAIN_ROCE_TABLE_ACT_MAIN_NOP: 
                                {
                                }
                                break;
                            case MAIN_ROCE_TABLE_ACT_NOACTION: 
                                {
                                }
                                break;
                        }
                    } else {
                    }
                }
;
            }
            else {
/* drop_packet() */
                drop_packet();            }

        }
    }
    {
        struct ipv4_t ip_1;
        __builtin_memset((void *) &ip_1, 0, sizeof(struct ipv4_t ));
        u16 chk_state = 0;
{
;
                        ip_1 = hdr->ip;
            /* chk.clear() */
            chk_state = 0;
;
            /* chk.set_state(~ip_1.hdrChecksum) */
            chk_state = ~ip_1.hdrChecksum;
;
            /* chk.subtract({ip_1.ttl, ip_1.protocol}) */
            {
                u16 chk_tmp = 0;
                chk_tmp = (ip_1.ttl << 8) | ip_1.protocol;
                chk_state = csum16_sub(chk_state, chk_tmp);
            }
;
                        ip_1.ttl = (ip_1.ttl + 255);
            /* chk.add({ip_1.ttl, ip_1.protocol}) */
            {
                u16 chk_tmp_0 = 0;
                chk_tmp_0 = (ip_1.ttl << 8) | ip_1.protocol;
                chk_state = csum16_add(chk_state, chk_tmp_0);
            }
;
                        ip_1.hdrChecksum = /* chk.get() */
((u16) (~chk_state));
                        hdr->ip = ip_1;
            ;
            ;
            ;
            ;
            ;
            ;
        }

        if (compiler_meta__->drop) {
            return TC_ACT_SHOT;
        }
        int outHeaderLength = 0;
        if (hdr->ethernet.ebpf_valid) {
            outHeaderLength += 112;
        }
;;;;;        if (ip_1.ebpf_valid) {
            outHeaderLength += 160;
        }
;        if (hdr->udp.ebpf_valid) {
            outHeaderLength += 64;
        }
;        if (hdr->ib_bth.ebpf_valid) {
            outHeaderLength += 96;
        }
;        if (hdr->ib_16byte_payload.ebpf_valid) {
            outHeaderLength += 128;
        }
;        if (hdr->ib_aeth.ebpf_valid) {
            outHeaderLength += 32;
        }
;        if (hdr->ib_icrc.ebpf_valid) {
            outHeaderLength += 32;
        }
;
        int outHeaderOffset = BYTES(outHeaderLength) - (hdr_start - (u8*)pkt);
        if (outHeaderOffset != 0) {
            int returnCode = 0;
            returnCode = bpf_skb_adjust_room(skb, outHeaderOffset, 1, 0);
            if (returnCode) {
                return TC_ACT_SHOT;
            }
        }
        pkt = ((void*)(long)skb->data);
        ebpf_packetEnd = ((void*)(long)skb->data_end);
        ebpf_packetOffsetInBits = 0;
        if (hdr->ethernet.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 112)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.dstAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[4];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 4, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.srcAddr))[5];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 5, (ebpf_byte));
            ebpf_packetOffsetInBits += 48;

            hdr->ethernet.etherType = bpf_htons(hdr->ethernet.etherType);
            ebpf_byte = ((char*)(&hdr->ethernet.etherType))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ethernet.etherType))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;;;;;        if (ip_1.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 160)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&ip_1.version))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&ip_1.ihl))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            ebpf_byte = ((char*)(&ip_1.diffserv))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ip_1.totalLen = bpf_htons(ip_1.totalLen);
            ebpf_byte = ((char*)(&ip_1.totalLen))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.totalLen))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ip_1.identification = bpf_htons(ip_1.identification);
            ebpf_byte = ((char*)(&ip_1.identification))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.identification))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&ip_1.flags))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 3, 5, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 3;

            ip_1.fragOffset = bpf_htons(ip_1.fragOffset << 3);
            ebpf_byte = ((char*)(&ip_1.fragOffset))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 5, 0, (ebpf_byte >> 3));
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0 + 1, 3, 5, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.fragOffset))[1];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 1, 5, 0, (ebpf_byte >> 3));
            ebpf_packetOffsetInBits += 13;

            ebpf_byte = ((char*)(&ip_1.ttl))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&ip_1.protocol))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ip_1.hdrChecksum = bpf_htons(ip_1.hdrChecksum);
            ebpf_byte = ((char*)(&ip_1.hdrChecksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.hdrChecksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&ip_1.srcAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.srcAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.srcAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.srcAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            ebpf_byte = ((char*)(&ip_1.dstAddr))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.dstAddr))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.dstAddr))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&ip_1.dstAddr))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (hdr->udp.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 64)) {
                return TC_ACT_SHOT;
            }
            
            hdr->udp.srcPort = bpf_htons(hdr->udp.srcPort);
            ebpf_byte = ((char*)(&hdr->udp.srcPort))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->udp.srcPort))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            hdr->udp.dstPort = bpf_htons(hdr->udp.dstPort);
            ebpf_byte = ((char*)(&hdr->udp.dstPort))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->udp.dstPort))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            hdr->udp.length_ = bpf_htons(hdr->udp.length_);
            ebpf_byte = ((char*)(&hdr->udp.length_))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->udp.length_))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            hdr->udp.checksum = bpf_htons(hdr->udp.checksum);
            ebpf_byte = ((char*)(&hdr->udp.checksum))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->udp.checksum))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

        }
;        if (hdr->ib_bth.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 96)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&hdr->ib_bth.opcode))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            ebpf_byte = ((char*)(&hdr->ib_bth.se))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 7, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&hdr->ib_bth.mig_req))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 6, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&hdr->ib_bth.pad_cnt))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 2, 4, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 2;

            ebpf_byte = ((char*)(&hdr->ib_bth.tver))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 4, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 4;

            hdr->ib_bth.p_key = bpf_htons(hdr->ib_bth.p_key);
            ebpf_byte = ((char*)(&hdr->ib_bth.p_key))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_bth.p_key))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_packetOffsetInBits += 16;

            ebpf_byte = ((char*)(&hdr->ib_bth.fecn_res1))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 7, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&hdr->ib_bth.becn_res1))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 6, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&hdr->ib_bth.res_var))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 6, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 6;

            hdr->ib_bth.dest_qp = htonl(hdr->ib_bth.dest_qp << 8);
            ebpf_byte = ((char*)(&hdr->ib_bth.dest_qp))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_bth.dest_qp))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_bth.dest_qp))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

            ebpf_byte = ((char*)(&hdr->ib_bth.ack_req))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 1, 7, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 1;

            ebpf_byte = ((char*)(&hdr->ib_bth.res))[0];
            write_partial(pkt + BYTES(ebpf_packetOffsetInBits) + 0, 7, 0, (ebpf_byte >> 0));
            ebpf_packetOffsetInBits += 7;

            hdr->ib_bth.pkt_seq = htonl(hdr->ib_bth.pkt_seq << 8);
            ebpf_byte = ((char*)(&hdr->ib_bth.pkt_seq))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_bth.pkt_seq))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_bth.pkt_seq))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

        }
;        if (hdr->ib_16byte_payload.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 128)) {
                return TC_ACT_SHOT;
            }
            
            hdr->ib_16byte_payload.word0 = htonl(hdr->ib_16byte_payload.word0);
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word0))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word0))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word0))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word0))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word1 = htonl(hdr->ib_16byte_payload.word1);
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word1))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word1))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word1))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word1))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word2 = htonl(hdr->ib_16byte_payload.word2);
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word2))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word2))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word2))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word2))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word3 = htonl(hdr->ib_16byte_payload.word3);
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word3))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word3))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word3))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_16byte_payload.word3))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;        if (hdr->ib_aeth.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            ebpf_byte = ((char*)(&hdr->ib_aeth.syndrome))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_packetOffsetInBits += 8;

            hdr->ib_aeth.msn = htonl(hdr->ib_aeth.msn << 8);
            ebpf_byte = ((char*)(&hdr->ib_aeth.msn))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_aeth.msn))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_aeth.msn))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_packetOffsetInBits += 24;

        }
;        if (hdr->ib_icrc.ebpf_valid) {
            if (ebpf_packetEnd < pkt + BYTES(ebpf_packetOffsetInBits + 32)) {
                return TC_ACT_SHOT;
            }
            
            hdr->ib_icrc.iCRC = htonl(hdr->ib_icrc.iCRC);
            ebpf_byte = ((char*)(&hdr->ib_icrc.iCRC))[0];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 0, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_icrc.iCRC))[1];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 1, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_icrc.iCRC))[2];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 2, (ebpf_byte));
            ebpf_byte = ((char*)(&hdr->ib_icrc.iCRC))[3];
            write_byte(pkt, BYTES(ebpf_packetOffsetInBits) + 3, (ebpf_byte));
            ebpf_packetOffsetInBits += 32;

        }
;
    }
    return -1;
}
SEC("p4tc/main")
int tc_ingress_func(struct __sk_buff *skb) {
    struct pna_global_metadata *compiler_meta__ = (struct pna_global_metadata *) skb->cb;
    if (compiler_meta__->pass_to_kernel == true) return TC_ACT_OK;
    if (!compiler_meta__->recirculated) {
        compiler_meta__->mark = 153;
        struct internal_metadata *md = (struct internal_metadata *)(unsigned long)skb->data_meta;
        if ((void *) ((struct internal_metadata *) md + 1) <= (void *)(long)skb->data) {
            __u16 *ether_type = (__u16 *) ((void *) (long)skb->data + 12);
            if ((void *) ((__u16 *) ether_type + 1) > (void *) (long) skb->data_end) {
                return TC_ACT_SHOT;
            }
            *ether_type = md->pkt_ether_type;
        }
    }
    struct hdr_md *hdrMd;
    struct headers_t *hdr;
    int ret = -1;
    ret = process(skb, (struct headers_t *) hdr, compiler_meta__);
    if (ret != -1) {
        return ret;
    }
    if (!compiler_meta__->drop && compiler_meta__->egress_port == 0) {
        compiler_meta__->pass_to_kernel = true;
        return bpf_redirect(skb->ifindex, BPF_F_INGRESS);
    }
    return bpf_redirect(compiler_meta__->egress_port, 0);
}
char _license[] SEC("license") = "GPL";
