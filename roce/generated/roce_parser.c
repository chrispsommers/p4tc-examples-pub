/* Automatically generated by p4c-pna-p4tc from roce.p4 on Thu Jun  6 17:42:19 2024
 */
#include "roce_parser.h"

struct p4tc_filter_fields p4tc_filter_fields;

static __always_inline int run_parser(struct __sk_buff *skb, struct headers_t *hdr, struct pna_global_metadata *compiler_meta__)
{
    struct hdr_md *hdrMd;

    unsigned ebpf_packetOffsetInBits_save = 0;
    ParserError_t ebpf_errorCode = NoError;
    void* pkt = ((void*)(long)skb->data);
    u8* hdr_start = pkt;
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u32 ebpf_zero = 0;
    u32 ebpf_one = 1;
    unsigned char ebpf_byte;
    u32 pkt_len = skb->len;

    struct metadata_t *meta;

    hdrMd = BPF_MAP_LOOKUP_ELEM(hdr_md_cpumap, &ebpf_zero);
    if (!hdrMd)
        return TC_ACT_SHOT;
    __builtin_memset(hdrMd, 0, sizeof(struct hdr_md));

    unsigned ebpf_packetOffsetInBits = 0;
    hdr = &(hdrMd->cpumap_hdr);
    meta = &(hdrMd->cpumap_usermeta);
    {
        goto start;
        parse_ib_aeth: {
/* extract(hdr->ib_aeth) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(32 + 8)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->ib_aeth.syndrome = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            hdr->ib_aeth.msn = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 8) & EBPF_MASK(u32, 24));
            ebpf_packetOffsetInBits += 24;


            hdr->ib_aeth.ebpf_valid = 1;
            hdr_start += BYTES(32);

;
             goto parse_ib_icrc;
        }
        parse_ib_cnp: {
/* extract(hdr->ib_16byte_payload) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(128 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->ib_16byte_payload.word0 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word1 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word2 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word3 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;


            hdr->ib_16byte_payload.ebpf_valid = 1;
            hdr_start += BYTES(128);

;
             goto parse_ib_icrc;
        }
        parse_ib_icrc: {
/* extract(hdr->ib_icrc) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(32 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->ib_icrc.iCRC = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;


            hdr->ib_icrc.ebpf_valid = 1;
            hdr_start += BYTES(32);

;
             goto accept;
        }
        parse_ib_rc_send_only: {
/* extract(hdr->ib_16byte_payload) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(128 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->ib_16byte_payload.word0 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word1 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word2 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;

            hdr->ib_16byte_payload.word3 = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 32;


            hdr->ib_16byte_payload.ebpf_valid = 1;
            hdr_start += BYTES(128);

;
             goto parse_ib_icrc;
        }
        parse_ipv4: {
/* extract(hdr->ip) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(160 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->ip.version = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            hdr->ip.ihl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            hdr->ip.diffserv = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            hdr->ip.totalLen = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            hdr->ip.identification = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            hdr->ip.flags = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 5) & EBPF_MASK(u8, 3));
            ebpf_packetOffsetInBits += 3;

            hdr->ip.fragOffset = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u16, 13));
            ebpf_packetOffsetInBits += 13;

            hdr->ip.ttl = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            hdr->ip.protocol = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            hdr->ip.hdrChecksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            __builtin_memcpy(&hdr->ip.srcAddr, pkt + BYTES(ebpf_packetOffsetInBits), 4);
            ebpf_packetOffsetInBits += 32;

            __builtin_memcpy(&hdr->ip.dstAddr, pkt + BYTES(ebpf_packetOffsetInBits), 4);
            ebpf_packetOffsetInBits += 32;


            hdr->ip.ebpf_valid = 1;
            hdr_start += BYTES(160);

;
            u8 select_0;
            select_0 = hdr->ip.protocol;
            if (select_0 == 17)goto parse_udp;
            if ((select_0 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_rocev2: {
/* extract(hdr->ib_bth) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(96 + 8)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->ib_bth.opcode = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 8;

            hdr->ib_bth.se = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 7) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            hdr->ib_bth.mig_req = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 6) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            hdr->ib_bth.pad_cnt = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 2));
            ebpf_packetOffsetInBits += 2;

            hdr->ib_bth.tver = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
            ebpf_packetOffsetInBits += 4;

            hdr->ib_bth.p_key = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            hdr->ib_bth.fecn_res1 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 7) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            hdr->ib_bth.becn_res1 = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 6) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            hdr->ib_bth.res_var = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 6));
            ebpf_packetOffsetInBits += 6;

            hdr->ib_bth.dest_qp = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 8) & EBPF_MASK(u32, 24));
            ebpf_packetOffsetInBits += 24;

            hdr->ib_bth.ack_req = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits)) >> 7) & EBPF_MASK(u8, 1));
            ebpf_packetOffsetInBits += 1;

            hdr->ib_bth.res = (u8)((load_byte(pkt, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 7));
            ebpf_packetOffsetInBits += 7;

            hdr->ib_bth.pkt_seq = (u32)((load_word(pkt, BYTES(ebpf_packetOffsetInBits)) >> 8) & EBPF_MASK(u32, 24));
            ebpf_packetOffsetInBits += 24;


            hdr->ib_bth.ebpf_valid = 1;
            hdr_start += BYTES(96);

;
            u8 select_1;
            select_1 = hdr->ib_bth.opcode;
            if (select_1 == 128)goto parse_ib_cnp;
            if (select_1 == 4)goto parse_ib_rc_send_only;
            if (select_1 == 17)goto parse_ib_aeth;
            if ((select_1 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        parse_udp: {
/* extract(hdr->udp) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(64 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            hdr->udp.srcPort = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            hdr->udp.dstPort = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            hdr->udp.length_ = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;

            hdr->udp.checksum = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;


            hdr->udp.ebpf_valid = 1;
            hdr_start += BYTES(64);

;
            u16 select_2;
            select_2 = hdr->udp.dstPort;
            if (select_2 == 4791)goto parse_rocev2;
            if ((select_2 & 0x0) == (0x0 & 0x0))goto accept;
            else goto reject;
        }
        start: {
/* extract(hdr->ethernet) */
            if ((u8*)ebpf_packetEnd < hdr_start + BYTES(112 + 0)) {
                ebpf_errorCode = PacketTooShort;
                goto reject;
            }

            __builtin_memcpy(&hdr->ethernet.dstAddr, pkt + BYTES(ebpf_packetOffsetInBits), 6);
            ebpf_packetOffsetInBits += 48;

            __builtin_memcpy(&hdr->ethernet.srcAddr, pkt + BYTES(ebpf_packetOffsetInBits), 6);
            ebpf_packetOffsetInBits += 48;

            hdr->ethernet.etherType = (u16)((load_half(pkt, BYTES(ebpf_packetOffsetInBits))));
            ebpf_packetOffsetInBits += 16;


            hdr->ethernet.ebpf_valid = 1;
            hdr_start += BYTES(112);

;
            u16 select_3;
            select_3 = hdr->ethernet.etherType;
            if (select_3 == 0x800)goto parse_ipv4;
            if ((select_3 & 0x0) == (0x0 & 0x0))goto reject;
            else goto reject;
        }

        reject: {
            if (ebpf_errorCode == 0) {
                return TC_ACT_SHOT;
            }
            compiler_meta__->parser_error = ebpf_errorCode;
            goto accept;
        }

    }

    accept:
    hdrMd->ebpf_packetOffsetInBits = ebpf_packetOffsetInBits;
    return -1;
}

SEC("p4tc/parse")
int tc_parse_func(struct __sk_buff *skb) {
    struct pna_global_metadata *compiler_meta__ = (struct pna_global_metadata *) skb->cb;
    struct hdr_md *hdrMd;
    struct headers_t *hdr;
    int ret = -1;
    ret = run_parser(skb, (struct headers_t *) hdr, compiler_meta__);
    if (ret != -1) {
        return ret;
    }
    return TC_ACT_PIPE;
    }
char _license[] SEC("license") = "GPL";
